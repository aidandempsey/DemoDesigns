-- Header Section
-- Generated by HDLGen, Github https://github.com/fearghal1/HDLGen

-- Component Name : RISCV_RB
-- Title          : 32 x 32-bit Register Bank, with chip enable. Single synchronous write port, dual combinational read ports

-- Description
-- x0 is always 0
-- 
-- writeReg <  synchronous write port
-- if rst asserted, high  
--   x = 0    immediately clear all registers
-- else if rising_edge (clk) 
--   registers unchanged
--   if ce = 1    
--     if RWr = 1  
--       if rd  0  
--         xrd = WBDat      synchronous write
-- 
-- readReg dual combinational read ports
-- rs1D = xrs1
-- rs2D = xrs2

-- Author(s)      : Fearghal Morgan
-- Company        : University of Galway
-- Email          : fearghal.morgan@universityofgalway.ie
-- Date           : 11/06/2023

-- entity signal dictionary
-- clk	System clk strobe, rising edge active
-- rst	asynchronous rst reset signals signal, asserted high
-- RWr	Synchronous register write enable, high asserted
-- rd	Destination register address, address 0 - 31
-- rs1	Source register 1 address
-- rs2	Source register 2 address
-- rs1D	Source register 1 data
-- rs2D	Source register 2 data
-- WBDat	Writeback data
-- ce	Chip enable, asserted high

-- internal signal dictionary
-- CSArray	Register array current state signal
-- NSArray	Register array next state signal

-- library declarations
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.MainPackage.all;

-- entity declaration
entity RISCV_RB is 
Port(
	clk : in std_logic;
	rst : in std_logic;
	RWr : in std_logic;
	rd : in std_logic_vector(4 downto 0);
	rs1 : in std_logic_vector(4 downto 0);
	rs2 : in std_logic_vector(4 downto 0);
	rs1D : out std_logic_vector(31 downto 0);
	rs2D : out std_logic_vector(31 downto 0);
	WBDat : in std_logic_vector(31 downto 0);
	ce : in std_logic
);
end entity RISCV_RB;

architecture RTL of RISCV_RB is
-- Internal signal declarations
signal CSArray : array32x32;
signal NSArray : array32x32;

begin

NSDecode_p: process(RWr,rd,WBDat,CSArray)
begin
	NSArray <= CSArray;-- Default assignment 
	
--- if RWr = '1' --- if rd > '0' --- NSArray(rd) = WBDat
end process;

--- rs1D_c: rs1D <= CSArray(rs1);


--- rs2D_c: rs2D <= CSArray(rs2);


stateReg_p: process(clk,rst)
begin
	if rst = '1' then
		CSArray <= (others =>(others => '0'));
	elsif rising_edge(clk) then
    	if ce = '1' then -- enable register
    		CSArray <= NSArray;
    	end if;
	end if;
end process;

end RTL;